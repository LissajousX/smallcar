先回答你两个问题：

---

## 1. STM32 现在大概还有多少资源能用？

基于你现在的小车工程（电机、舵机、PS2、串口、电池 ADC），再结合 F103C8 的规格，可以大致这么看：

- **Flash / RAM**
  - F103C8：64KB Flash、20KB RAM。
  - 你现在的工程（电机+PS2+遥控+电池+串口）典型编译后大概在 **20–40KB Flash、几 KB RAM** 级别。
  - 也就是说：**程序空间和内存都还是很富裕**，再加 OLED、IMU、外部 Flash 之类问题不大。

- **外设总线**
  - **I2C1**：目前看你工程里还没用，可以挂：
    - MPU6050 陀螺仪（IMU）
    - 0.96 寸 OLED（多数是 I2C/SSD1306）
    - 这俩可以 **共用一组 SCL/SDA**。
  - **SPI1**：空闲，可以挂 W25Q64 存储。
  - **USART**：USART1 已给 ESP32 用。USART2 / USART3 仍然可用（如果你需要额外串口）。
  - **ADC**：现在只用了 `ADC1_IN2 (PA2)` 做电池采样，**还剩很多 ADC 通道**，可以接：
    - 热敏电阻
    - 光敏电阻
    - 电位器等。

- **GPIO / 定时器**
  - 定时器：电机和舵机占了部分 Timer 和 PWM 通道，但 F103 还有 **多个剩余通道**，足够驱动有源蜂鸣器、编码器计数等。
  - GPIO：根据之前的 [pins.md](cci:7://file:///d:/smallcar/smallcar_keil/pins.md:0:0-0:0) 印象，除去电机、舵机、PS2、串口、电池 ADC，**仍然有十来个 IO 可用**，足够你把上面这些模块都挂上（不一定一次全用）。

总之：**资源还很宽裕，可以放心再加几块外设做花活**。

---

## 2. 用你这些模块可以做哪些有意思的功能？

下面给几个跟“小车”有关系、而且比较实用/好玩的方向，你可以按兴趣挑几条实现：

### 2.1 低电量报警 & 提示音（有源蜂鸣器）

- **用到**：有源蜂鸣器、现有电池百分比。
- **玩法**：
  - 当 [Battery_ConvertPercent()](cci:1://file:///d:/smallcar/smallcar_keil/main.c:149:0-169:1) 返回值低于某阈值（比如 20%、10%）：
    - 鸣叫“滴滴滴”（短促快节奏）提示赶紧充电。
    - 若继续下降，可以改成长鸣或频率不同的声音。
  - 倒车时蜂鸣器“滴…滴…滴…”当作倒车雷达音效。
- **实现点**：
  - 有源蜂鸣器只要 **一个 GPIO 输出 + Timer/PWM（可选）**；简单点直接 `GPIO 高/低` 方波即可。

### 2.2 “状态仪表盘” OLED（车上本地显示）

- **用到**：0.96 寸 OLED（多半 I2C）、I2C1。
- **显示内容**（不看网页也能知道状态）：
  - 电池电量：`78% 12.1V`
  - 当前模式：手动 / Web 遥控 / 将来自动驾驶
  - 当前油门/转向值，或“停止 / 前进 / 后退”
  - 连接状态：ESP32 WiFi OK / Web 未连 等。
- **扩展**：
  - 结合编码器或按键做一个**小菜单**：比如设置最高速度、转向灵敏度、开启/关闭自动灯光等。

### 2.3 MPU6050 IMU：姿态检测 & 稳定

- **用到**：6050 陀螺仪（I2C）、OLED。
- **玩法**：
  - **倾斜/翻车检测**：如果车倾斜超出一定角度，自动刹车并蜂鸣报警。
  - 在 OLED 上画一个小水平仪，显示车身前后/左右倾角。
  - 长远一点，可以做个 **“姿态稳定模式”**：比如上坡时自动稍微加功率，下坡限制速度。
- **实现点**：
  - MPU6050 同样挂在 I2C1 上，和 OLED 共线。
  - 用简单互补滤波得到 roll / pitch 足够了，先不用卡尔曼。

### 2.4 反射式红外：防跌落 / 简易循迹

- **用到**：反射式红外传感（模拟输出，接 ADC 或数字比较）、有源蜂鸣器、LED。
- **玩法 A：防跌落**（桌面测试很好玩）：
  - 传感器朝下，对比桌面 vs 悬空的反射差异。
  - 检测到前方是“黑色 / 空”，立刻停车 + 蜂鸣器报警。
- **玩法 B：简易循迹**（在地面贴黑胶带）：
  - 传感器对准地面，黑线反射小、白地反射大。
  - 根据值调节左右电机，做最简单的单点循迹。
- **实现点**：
  - 接到 **一个 ADC 通道或数字输入**，适当门限即可。

### 2.5 光敏 / 温度：环境感知 + 灯光联动

- **用到**：光敏电阻、热敏电阻、LED 灯若干。
- **玩法**：
  - **自动车灯**：光线暗时自动点亮车前灯（LED），亮时关闭。
  - **温度监控**：检测小车附近温度（比如电机/电池附近），过热时限速或报警。
  - 也可以把这些信息：
    - 显示在 OLED 上；
    - 通过 ESP32 发到 Web，做环境仪表盘。
- **实现点**：
  - LDR / NTC 作为分压的一只，接到 **ADC 通道** 再软件换算。

### 2.6 360° 旋转编码器 / 电位器：本地控制旋钮

- **用到**：360 度旋转编码器、3362P 电位器。
- **玩法**：
  - 作为车上的 **“模式旋钮”**：
    - 档位 0：停车
    - 档位 1：手动遥控
    - 档位 2：自动循迹
    - 档位 3：演示模式
  - 或者调节一个全局参数：比如 **最高速度 / 转向灵敏度 / PID 增益**。
- **实现点**：
  - 编码器：2 个数字输入 + 中断/轮询。
  - 电位器：接 ADC，读出 0–4095 做归一化。

### 2.7 W25Q64 外部存储：行驶数据黑盒 / 轨迹回放

- **用到**：W25Q64（SPI Flash）、SPI1、MPU6050 / 遥控数据。
- **玩法**：
  - 挂上外部 Flash，当作 **小车“黑盒”**：
    - 定时记录：时间戳、油门、转向、电池电量、IMU 姿态。
  - 回到家后：
    - 通过 ESP32 提供一个 Web 接口，把数据导出；
    - 在 PC 上画出行驶曲线、电量消耗曲线等。
- **实现点**：
  - SPI1 用几根空闲 IO 就够，简单先实现按扇区存取。

### 2.8 数码管（4 位共阳）：离线显示速度 / 电量

- **用到**：0.56 寸 4 位共阳数码管、几十个 LED/1k 电阻也能做指示。
- **玩法**：
  - 脱离 Web / OLED 时：
    - 显示当前**速度百分比**或**电量百分比**（两位数）。
    - 或者轮流显示“电量”、“错误码”等。
- **实现点**：
  - 用 4 个位选 + 7 段共用线，**1 个定时器中断做轮询扫描**就能驱动。
  - IO 占用会比 OLED 多一些，必要时可以只点亮部分段位/数字。

---

## 3. 怎么选优先做哪些？

如果按“性价比 / 实用度”排序，我会建议：

1. **电池低电量蜂鸣报警 + Web / OLED 显示同步**  
2. **I2C 总线：先挂 OLED，再挂 MPU6050**（一个做状态面板，一个做姿态检测）。  
3. **反射红外做防跌落/循迹**（对小车玩法提升很大）。  
4. 之后再考虑：W25Q64 数据记录、光敏/热敏传感器、编码器模式旋钮、数码管等。

你可以先选一两个你最想做的，我可以帮你具体设计：  
- 接线图（用现在 pins.md 里剩余的口），  
- STM32 驱动代码结构（放到哪个模块里、如何和现有 main.c 配合），  
- 以及是否要把新数据也透传到 ESP32/Web 上。

---

```text
Move battery indicator into status panel header and wire it to existing /battery polling.
```

下面我按“要记录什么、存哪里、怎么回放”三块，把**轨迹回放**这个功能讲细一点，尽量贴合你现有 STM32 + ESP32 + Web 的架构。

---

## 1. 轨迹回放到底是什么？

你可以把“轨迹”理解成一段时间内的**时间序列记录**：

- **输入**（你对车的控制）  
  - 油门 `throttle`  
  - 转向 `steer`  
  - 云台角度 `yaw / pitch`  
  - 也可以记当前“模式、速度档位”等

- **状态/传感器**（车本身发生了什么）  
  - 电池电量、电压  
  - IMU（6050）的姿态：roll / pitch / yaw 或原始加速度、角速度  
  - 以后也可以加：光线、温度、是否检测到边缘/障碍 etc.

“回放”则有两种层次：

1. **命令级回放**：  
   按当时的时间间隔，把记录好的 `C,throttle,steer,yaw,pitch` 重新发给 STM32，  
   车会“按当时的操作再开一遍”。

2. **可视化回放**：  
   不一定真的让车再跑一遍，而是在 Web 上：
   - 用时间轴 + 曲线图重现当时的`油门/转向/姿态/电池`变化；
   - 如果有简单位置估计（IMU + 里程计），甚至可以在平面上画出一条“跑过的路径”。

先实现第 1 种就已经很好玩，并且工程量相对可控。

---

## 2. 日志放在哪：STM32 + W25Q64 还是 ESP32 还是路由器？

你现在有 W25Q64 模块，这是个 8MByte 级别的 SPI Flash，很适合当“黑盒”。

### 方案 A：**STM32 + W25Q64 本地黑盒**（推荐起步）

- **接线**：  
  - W25Q64 接 STM32 的 SPI1（SCK/MISO/MOSI + 一个 CS）。  
  - STM32 负责写入整个日志。

- **优点**：
  - 就算 ESP32、WiFi 或 Web 都挂了，轨迹照样存；  
  - 跟“车体”强绑定，你拿板子就能把轨迹导出来。

- **如何把数据取出来**：
  - STM32 通过串口命令，把 Flash 中的记录一段段发给 ESP32，  
  - ESP32 再提供一个 HTTP 下载接口，比如 `/track.bin`，  
  - 你在电脑浏览器下载这个文件，用 Python/网页工具解析后画图或离线分析。

- **如何在车上“重跑”**：
  - STM32 直接读回 W25Q64 里的轨迹记录，根据时间戳，  
  - 在主循环里把当年的 `throttle/steer` 重放到 `Motor_SetLR` 和 `Servo_SetYaw/Pitch`，  
  - 此时**忽略遥控/WS 控制**，进入“回放模式”。

### 方案 B：**ESP32 记录 + 路由器/电脑存储**

- ESP32 已经看到所有 Web 控制 JSON，  
  你也可以在 ESP32 上：
  - 把控制 JSON + 时间戳存到它自己的 Flash 或直接 POST 到你的 `video_app.py`；
  - 最终轨迹文件存在路由器或 PC 上。
- 优点：
  - 不用再接 W25Q64；  
  - PC 端处理方便。
- 缺点：
  - 没有网络就没法记录；  
  - 想在车上本地“回放跑一遍”就麻烦一点（要再下发回来）。

你手上既然有 W25Q64，我觉得**可以选 A 做一个“车载黑盒”，配合 ESP32 做导出**是很酷也很完整的方案。

---

## 3. 日志里具体记什么、怎么打包？

为了简单、稳定，可以设计一个**固定长度的记录结构**，比如每 50ms 或 100ms 记一条：

- **每条记录字段示例**（二进制格式）：

  | 字段        | 类型        | 含义                          |
  |-------------|-------------|-------------------------------|
  | tick_ms     | uint32 4B   | 相对起点的毫秒数（或 10ms 片）|
  | throttle    | int16 2B    | -100..100（放大小或直接存）   |
  | steer       | int16 2B    | -100..100                     |
  | yaw         | int16 2B    | 0..180                        |
  | pitch       | int16 2B    | 0..180                        |
  | vbat_mv     | uint16 2B   | 电池电压（mV / 10mV 单位）    |
  | flags       | uint8  1B   | 模式、错误标志等              |
  | reserved    | uint8  1B   | 对齐备用                      |

  - 一条记录 ~16 字节，  
    8MB Flash 理论上可存 50 万条以上记录：  
    - 若 20Hz 采样（50ms 一条），可录 **> 7 小时**。

- **文件结构**：

  建议每次“录制一次”就写一个 **session**：

  - **Header**（比如 64 字节）：
    - Magic：`'TRK1'`（轨迹格式版本）
    - 采样周期：比如 50ms
    - 起始时间（可选）
    - 记录条数（最后写回）
  - **Body**：上面那种固定长度 record 连续排列。

- **写入策略**：

  - STM32 起一个“录制模式”开关：
    - 打开录制：擦除或分配好一个区域，从头顺序写；  
    - 关闭录制：补写 header 中的“记录条数”等信息。
  - 写入时避免频繁擦写同一扇区，可以：
    - 每个扇区顺序写满，再换下一个；
    - 或做简易“环形缓冲区”（用一部分 Flash 不断覆盖旧数据，只保留最近 N 分钟）。

---

## 4. 回放时在车上发生什么？

### 4.1 本地回放（车自己再跑一遍）

1. 进入“回放模式”（比如用按键或 Web 指令 `/replay/start`）。
2. STM32：
   - 先加载当前 session 的 header，取出采样周期、记录条数；
   - 把当前车速、控制来源切成“由回放驱动”，**屏蔽遥控**。
3. 在主循环或一个专门任务里：
   - 维护一个`replay_index`和`replay_tick`；
   - 按时间（或简单每次 loop 50ms）读下一条记录：
     - 用记录里的 `throttle/steer` 计算左右电机输出；
     - 用 `yaw/pitch` 设置云台；
   - 播完最后一条后自动退出回放模式，停车。

注意：

- 实际情况可能和当时略有偏差（轮胎打滑、电池变弱、地形不同），  
  但大致“路线/动作”会类似。
- 如果你用了 IMU 或里程计做闭环，也可以在回放时做一些校正，但那是进阶版。

### 4.2 Web 上的“轨迹可视化回放”

即使你暂时不让车真跑，也可以在网页上做一个“演示播放器”：

- ESP32 或路由器提供接口：
  - `/track/list`：列出已有 session；
  - `/track/data?id=xxx`：下载某次记录的二进制或 JSON。
- 前端：
  - 解析后，在 JS 里做一个简单播放器：
    - 左边：随时间变化的油门/转向/电池曲线；
    - 右边：如果有姿态/位置，可画出“车的路径”；否则画一个“方向+速度”的示意。
  - 再加一个进度条、播放/暂停按钮，就像播放一段录制好的 demo。

这样你可以在家里、不开车的情况下，把小车一次“冒险”整个回放并分析：哪段速度太高、电量掉得快、有没有翻车危险等。

---

## 5. 建议的起步路线

如果你想真做这个功能，我建议分 3 小步：

1. **先在 STM32 里搞清楚“采样结构”**：  
   定义好一个`struct TrackRecord`，每 50ms 在 RAM 里存一条，先不写 Flash，确认字段和频率合适。

2. **加 W25Q64 驱动 + 简单顺序写入/读出**：  
   - 实现：开始录制 → 写 header+记录 → 结束录制；  
   - 实现一个串口命令：比如 `DUMP`，把当前记录从 STM32 打出来，用 PC 小脚本解析。

3. **最后再接到 ESP32 + Web**：  
   - 让 ESP32 通过串口命令触发“开始/结束录制”；  
   - 通过串口拉一遍数据，提供 `/track.bin` 下载；  
   - 以后再在 Web 上做 JS 播放器或命令级回放模式。

---

如果你愿意下一步就做，我可以先帮你：

- 设计 `TrackRecord` 这个结构 + 简单 C 版 W25Q64 读写接口的轮廓；
- 或者先从“RAM 里假装有轨迹数据，在 Web 上画时间轴回放”开始，等你确认想法再接 Flash。


